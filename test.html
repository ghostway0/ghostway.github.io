<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">
  <link rel="stylesheet" href="style.css">
  <title>Curve Trees - Introduction</title>
</head>
<body>
  <header>
    <h1>Curve Trees - Introduction</h1>
    <p><em></em></p>
  </header>
  
  <main>
    <div id="txtdiv">
      <p>Curve Trees <a href="#ref-cryptoeprint:2022/756">[1]</a> are a
      cryptographic data<br />
      structure used to accumulate values and prove if values are
      members of<br />
      the accumulated set. They are to be used in Monero’s FCMP (Full
      Chain<br />
      Membership Proofs)<a href="#fn1" class="footnote-ref" id="fnref1"
      role="doc-noteref"><sup>1</sup></a> – the future replacement of
      ring signatures – and<br />
      for a good reason:</p>
      <table>
      <colgroup>
      <col style="width: 15%" />
      <col style="width: 67%" />
      <col style="width: 17%" />
      </colgroup>
      <thead>
      <tr>
      <th></th>
      <th>d-CLSAG <a href="#ref-cryptoeprint:2019/654">[2]</a>
      (d=1)</th>
      <th>Curve Trees</th>
      </tr>
      </thead>
      <tbody>
      <tr>
      <td>set size</td>
      <td>90</td>
      <td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mn>40</mn></msup><annotation encoding="application/x-tex">2^{40}</annotation></semantics></math></td>
      </tr>
      <tr>
      <td>proof size</td>
      <td>2.9KiB</td>
      <td>2.9KiB</td>
      </tr>
      </tbody>
      </table>
      <p>Furthermore, they eliminate the need for Monero’s 10 block lock
      rule, as<br />
      they don’t leak decoys<a href="#fn2" class="footnote-ref"
      id="fnref2" role="doc-noteref"><sup>2</sup></a>. Currently, Monero
      uses the ring signature’s<br />
      key image to prevent double spends of the same ‘enote’<a
      href="#fn3" class="footnote-ref" id="fnref3"
      role="doc-noteref"><sup>3</sup></a>; Seraphis<br />
      separated these into a proof of membership and a proof of
      authorization,<br />
      letting ‘pure’ membership proof schemes – such as Curve Trees – to
      be<br />
      used.</p>
      <h2 id="why-should-i-care">Why should I care?</h2>
      <ul>
      <li>You don’t want to read the paper, but want to read about curve
      trees,</li>
      <li>You think this is cool,</li>
      <li>???? &lt;– That’s the best part!</li>
      <li>Profit.</li>
      </ul>
      <p>Because you clicked on whatever link brought you to a page
      about Curve<br />
      Trees; obviously, you’re interested. Anyway, who doesn’t want to
      impress<br />
      their friends with crypto knowledge at the next party? “Curve
      Trees are<br />
      a multi-level marketi- set membership scheme, that lets you be
      your own<br />
      boss! You just need to invest <em>a bit</em>. Commit here, here
      here and here.”<br />
      Instant party hit.</p>
      <h2 id="assumed-knowledge">Assumed knowledge</h2>
      <p>You must have basic math knowledge about fields and<br />
      groups<a href="#ref-cseedu:brubaker/152groups">[3]</a>. Elliptic
      curves can be<br />
      treated as an algebraic construct that is defined over a field
      called<br />
      the base field. You do need to assume, even as merely a black box,
      that<br />
      points on elliptic curves form a cyclic (and thus also an
      abelian,<br />
      better known as a commutative) group, with the identity being the
      “point<br />
      at infinity”
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒪</mi><annotation encoding="application/x-tex">\mathcal{O}</annotation></semantics></math>.
      For an introduction, look at <a
      href="https://www.math.brown.edu/johsilve/Presentations/WyomingEllipticCurve.pdf">these<br />
      slides</a>.<br />
      This post is not self contained, but I keep quite a
      comprehensive<br />
      <a href="#references">bibliography</a> at the end. Note the use
      of<br />
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">⟨</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">⟩</mo></mrow><annotation encoding="application/x-tex">\langle a, b \rangle</annotation></semantics></math>
      to represent the inner product<a href="#fn4" class="footnote-ref"
      id="fnref4" role="doc-noteref"><sup>4</sup></a>.</p>
      <figure>
      <img src="https://i.ibb.co/9qcDws4/untitled-8.png"
      alt="Elliptic Curves! (xkcd 2048)" /><br />

      <figcaption aria-hidden="true">
      Elliptic Curves! (xkcd 2048)
      </figcaption>
      </figure>
      <p>The Curve Trees paper assumes the hardness of the Discrete Log
      Problem<br />
      (DLP). It basically means that it is hard to find
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
      from the knowledge<br />
      of
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>G</mi><annotation encoding="application/x-tex">G</annotation></semantics></math>
      and
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math>
      with the relation<br />
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">[</mo><mi>n</mi><mo stretchy="true" form="postfix">]</mo></mrow><mi>G</mi><mo>=</mo><munder><munder><mrow><mi>G</mi><mo>+</mo><mi>…</mi><mo>+</mo><mi>G</mi></mrow><mo accent="true">⏟</mo></munder><mtext mathvariant="normal">n times</mtext></munder><mo>=</mo><mi>P</mi></mrow><annotation encoding="application/x-tex">[n]G = \underbrace{G + \ldots + G}_{\text{n times}} = P</annotation></semantics></math>.</p>
      <p>Many zero-knowledge proofs use what’s called C&amp;P (Commit
      and Prove)<br />
      schemes: they commit to a value–something that lets them
      ‘represent’ the<br />
      value without revealing it–and then prove with that commitment
      some<br />
      knowledge.</p>
      <p>Commitments are functions on vectors which:</p>
      <ol type="1">
      <li><p>bind to the committed value: it is computationally hard to
      commit to<br />
      a value, and then find another opening (value) that ‘encodes’ to
      the<br />
      same commitment; and</p></li>
      <li><p>also are perfectly or computationally hiding.</p></li>
      </ol>
      <p>Pedersen commitments are commonly used in ZK proofs and
      structures: they<br />
      are homomorphic<a href="#fn5" class="footnote-ref" id="fnref5"
      role="doc-noteref"><sup>5</sup></a>, simple and lightweight –
      making them an easy<br />
      choice. They are defined as<br />
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>o</mi><mi>m</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>v</mi><mo>,</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mo>∑</mo><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>v</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow><msub><mi>G</mi><mi>i</mi></msub><mo>+</mo><mrow><mo stretchy="true" form="prefix">[</mo><mi>s</mi><mo stretchy="true" form="postfix">]</mo></mrow><mi>H</mi><mo>=</mo><mo stretchy="false" form="prefix">⟨</mo><mi>v</mi><mo>,</mo><mi>G</mi><mo stretchy="false" form="postfix">⟩</mo><mo>+</mo><mrow><mo stretchy="true" form="prefix">[</mo><mi>s</mi><mo stretchy="true" form="postfix">]</mo></mrow><mi>H</mi><mo>∈</mo><mi>E</mi><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>𝔽</mi><mi>q</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">Com(v, s) = \sum [v_i]G_i + [s]H = \langle v, G \rangle + [s]H \in E[\mathbb{F}_q]</annotation></semantics></math>,<br />
      where
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math>
      is the blinding factor and
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>v</mi><annotation encoding="application/x-tex">v</annotation></semantics></math>
      is the opening, or the vector<br />
      we are committing to.
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>i</mi></msub><mo>,</mo><mi>H</mi><mo>∈</mo><mi>E</mi><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>𝔽</mi><mi>q</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">G_i,H \in E[\mathbb{F}_q]</annotation></semantics></math>,
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>𝔽</mi><mi>q</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">E[\mathbb{F}_q]</annotation></semantics></math><br />
      being an elliptic curve on the field
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝔽</mi><mi>q</mi></msub><annotation encoding="application/x-tex">\mathbb{F}_q</annotation></semantics></math>.
      You’d notice I’m<br />
      using
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝔽</mi><mi>q</mi></msub><annotation encoding="application/x-tex">\mathbb{F}_q</annotation></semantics></math>
      and not the usual
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝔽</mi><mi>p</mi></msub><annotation encoding="application/x-tex">\mathbb{F}_p</annotation></semantics></math>
      – that’s on<br />
      purpose. :)</p>
      <p>Pedersen commitments are great for yet another reason: they
      are<br />
      re-randomizable. So if you have a tree, 1. you can re-randomize
      its<br />
      entries so that it cannot be linked to the other tree, and 2.
      it’s<br />
      really easy (computationally) to do so.<br />
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>e</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>d</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>C</mi><mi>o</mi><mi>m</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>v</mi><mo>,</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>r</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>C</mi><mi>o</mi><mi>m</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>v</mi><mo>,</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mrow><mo stretchy="true" form="prefix">[</mo><mi>r</mi><mo stretchy="true" form="postfix">]</mo></mrow><mi>H</mi><mo>=</mo><mo stretchy="false" form="prefix">⟨</mo><mi>v</mi><mo>,</mo><mi>G</mi><mo stretchy="false" form="postfix">⟩</mo><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> </mtext><mspace width="0.333em"></mspace></mrow><mo>+</mo><mrow><mo stretchy="true" form="prefix">[</mo><mi>s</mi><mo>+</mo><mi>r</mi><mo stretchy="true" form="postfix">]</mo></mrow><mi>H</mi><mo>=</mo><mi>C</mi><mi>o</mi><mi>m</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>v</mi><mo>,</mo><mi>s</mi><mo>+</mo><mi>r</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">Rerand(Com(v, s), r) = Com(v, s) + [r]H = \langle v, G \rangle \text{ } + [s + r]H = Com(v, s + r)</annotation></semantics></math></p>
      <p>In curve trees, Pedersen commitments are used as a compressor
      function<br />
      at every level of the tree. Think Merkle Trees, but using
      Pedersen<br />
      commitments as a hash and
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>⋅</mo><mtext mathvariant="normal">degree</mtext></mrow><annotation encoding="application/x-tex">2 \cdot \text{degree}</annotation></semantics></math>
      field elements –<br />
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(x, y)</annotation></semantics></math><a
      href="#fn6" class="footnote-ref" id="fnref6"
      role="doc-noteref"><sup>6</sup></a> of
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtext mathvariant="normal">degree</mtext><annotation encoding="application/x-tex">\text{degree}</annotation></semantics></math>
      points as
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>v</mi><annotation encoding="application/x-tex">v</annotation></semantics></math>.
      You would notice that,<br />
      because the elliptic curve group is cyclic, scalars – the ones we
      use<br />
      for multiplication operations on the elliptic curve – are
      essentially<br />
      modulo the order of the group, or, in its scalar field<a
      href="#fn7" class="footnote-ref" id="fnref7"
      role="doc-noteref"><sup>7</sup></a>. Say<br />
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝔽</mi><mi>p</mi></msub><annotation encoding="application/x-tex">\mathbb{F}_p</annotation></semantics></math>
      is
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>𝔽</mi><mi>q</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">E[\mathbb{F}_q]</annotation></semantics></math>’s
      scalar field.<br />
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>,</mo><mi>y</mi><mo>∈</mo><msub><mi>𝔽</mi><mi>q</mi></msub></mrow><annotation encoding="application/x-tex">x,y \in \mathbb{F}_q</annotation></semantics></math>,
      but they also need to be in
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝔽</mi><mi>p</mi></msub><annotation encoding="application/x-tex">\mathbb{F}_p</annotation></semantics></math>.<br />
      Naturally<a href="#fn8" class="footnote-ref" id="fnref8"
      role="doc-noteref"><sup>8</sup></a>, we ask why can’t
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">p = q</annotation></semantics></math>,
      but that is not possible, or at<br />
      least not possible to do securely <a
      href="#ref-cryptoeprint:2014/595">[5, Sec.<br />
      3.1]</a>,<br />
      <a href="#ref-cryptostackexchange:106774">[6]</a>.</p>
      <p>This ‘type mismatch’ has been seen before in zk proofs: earlier
      methods,<br />
      such as and some ETH zero knowledge contracts, emulate(d)
      field<br />
      arithmetic on one field with operations on another for the exact
      same<br />
      reason; committing produces results in the base field, and proving
      needs<br />
      to work on the scalar field <a
      href="#ref-blogicme:canweavoidcycles">[7]</a>,<br />
      <a href="#ref-blogpersonlabs:efficientecdsa">[8]</a> <a
      href="#fn9" class="footnote-ref" id="fnref9"
      role="doc-noteref"><sup>9</sup></a>. That’s called “wrong<br />
      field arithmetic” or “non-native arithmetic”, and is too slow to
      be<br />
      practical: circuits using it can be 100 to 200 times larger<a
      href="#ref-slides:deepdiveonhalo2">[10, p.<br />
      38]</a>. They found that we could, however,<br />
      define that two elliptic curves have complementing cardinalities
      and<br />
      orders, as in, one’s scalar field being the base field of the
      other.<br />
      meaning every odd and even layers will be points of
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>E</mi><mrow><mi>o</mi><mi>d</mi><mi>d</mi></mrow></msub><annotation encoding="application/x-tex">E_{odd}</annotation></semantics></math>
      and<br />
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>E</mi><mrow><mi>e</mi><mi>v</mi><mi>e</mi><mi>n</mi></mrow></msub><annotation encoding="application/x-tex">E_{even}</annotation></semantics></math>
      respectively, using the pedersen commitment as an adaptor.<br />
      that would work, but do such curves exist?</p>
      <figure>
      <img
      src="https://media.springernature.com/lw685/springer-static/image/art%3A10.1007%2Fs10623-022-01135-y/MediaObjects/10623_2022_1135_Fig1_HTML.png"
      alt="Elliptic curve Cycles [11]" /><br />

      <figcaption aria-hidden="true">
      Elliptic curve Cycles <span class="citation"
      data-cites="springer:asurveyproofsys"><a
      href="#ref-springer:asurveyproofsys"
      role="doc-biblioref">[11]</a></span>
      </figcaption>
      </figure>
      <p>Surprisingly, yes!</p>
      <p>(A bit) More formally, Curve Trees are the algebraic
      structure<br />
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mo>ℓ</mo><mo>,</mo><msub><mi>E</mi><mrow><mi>e</mi><mi>v</mi><mi>e</mi><mi>n</mi></mrow></msub><mo>,</mo><msub><mi>E</mi><mrow><mi>o</mi><mi>d</mi><mi>d</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(\ell, E_{even}, E_{odd})</annotation></semantics></math>,
      where
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>ℓ</mo><annotation encoding="application/x-tex">\ell</annotation></semantics></math>
      is the branching factor of the<br />
      tree, with the
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>ℓ</mo><annotation encoding="application/x-tex">\ell</annotation></semantics></math>
      children at each layer compressed by their parent<br />
      with the alternating compression functions<br />
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><msub><mi>E</mi><mrow><mi>e</mi><mi>v</mi><mi>e</mi><mi>n</mi></mrow></msub></msub><mo>:</mo><mspace width="1.0em"></mspace><msubsup><mi>E</mi><mrow><mi>o</mi><mi>d</mi><mi>d</mi></mrow><mo>ℓ</mo></msubsup><mo>↦</mo><msub><mi>E</mi><mrow><mi>e</mi><mi>v</mi><mi>e</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{E_{even}}: \quad E_{odd}^{\ell} \mapsto E_{even}</annotation></semantics></math>
      and<br />
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><msub><mi>E</mi><mrow><mi>o</mi><mi>d</mi><mi>d</mi></mrow></msub></msub><mo>:</mo><mspace width="1.0em"></mspace><msubsup><mi>E</mi><mrow><mi>e</mi><mi>v</mi><mi>e</mi><mi>n</mi></mrow><mo>ℓ</mo></msubsup><mo>↦</mo><msub><mi>E</mi><mrow><mi>o</mi><mi>d</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{E_{odd}}: \quad E_{even}^{\ell} \mapsto E_{odd}</annotation></semantics></math>
      being Pedersen<br />
      commitments as explained earlier. The tree is defined recursively,
      where<br />
      leaves make up the set of values we can commit to. Those are
      compressed<br />
      by the aforementioned compression function, until the root is
      reached.</p>
      <figure>
      <img src="https://i.ibb.co/FH9GkCT/2024-06-28-21-42.png"
      alt="Curve Trees paper [1] fig. 3; The orange path is the path to the leaf." /><br />

      <figcaption aria-hidden="true">
      Curve Trees paper <span class="citation"
      data-cites="cryptoeprint:2022/756"><a href="#ref-cryptoeprint:2022/756"
      role="doc-biblioref">[1]</a></span> fig. 3; The orange path is the
      path<br />
      to the leaf.
      </figcaption>
      </figure>
      <p>Let’s return to why we even wanted this construction: we wanted
      a tree.</p>
      <p>Just kidding, we wanted to prove that a value we selected is in
      some<br />
      set. So how can we do that here? We can publish the path to the
      value,<br />
      but that wouldn’t be zero-knowledge. We need something to prove we
      did<br />
      the procedure correctly! Choosing Pedersen commitments was a
      fortunate<br />
      choice in this regard, as many efficient proof systems exist for
      them,<br />
      such as Bulletproofs<a href="#ref-cryptoeprint:2017/1066">[12]</a>
      (which I’ll<br />
      cover in the next post), many SNARKs/STARKs, PLONK, etc. Those
      systems<br />
      allow you to prove that we built the tree correctly, by
      constraining the<br />
      commitment to be generated by its children, and the path element
      be one<br />
      of them, but re-ranzomized. In the paper, Bulletproofs are used
      to<br />
      generate a proof for these re-randomized commitments, and because
      we use<br />
      different curves for odd and even layers, we generate two proofs:
      one<br />
      for the odd layers and the other for the even ones.</p>
      <figure>
      <img src="https://imgs.xkcd.com/comics/tree.png"
      alt="We love trees! (xkcd 835)" /><br />

      <figcaption aria-hidden="true">
      We love trees! (xkcd 835)
      </figcaption>
      </figure>
      <p>Bulletproofs are incredibly interesting and are a centric
      component for<br />
      this scheme/structure. The next blog is going to be concerned with
      how<br />
      they work and the generalization the authors provided to enable
      this<br />
      structure. Thanks for reading!</p>
      <h1 id="references">References</h1>
      <div id="refs" class="references csl-bib-body"
      data-entry-spacing="0" role="list">
      <div id="ref-cryptoeprint:2022/756" class="csl-entry"
      role="listitem">
      <div class="csl-left-margin">[1]<br />
      </div><div class="csl-right-inline">M. Campanelli, M.
      Hall-Andersen,<br />
      and S. H. Kamp, “Curve trees: Practical and transparent
      zero-knowledge<br />
      accumulators.” Cryptology ePrint Archive, Paper 2022/756,
      2022.<br />
      Available: <a href="https://eprint.iacr.org/2022/756"
      class="uri">https://eprint.iacr.org/2022/756</a></div>
      </div>
      <div id="ref-cryptoeprint:2019/654" class="csl-entry"
      role="listitem">
      <div class="csl-left-margin">[2]<br />
      </div><div class="csl-right-inline">B. Goodell, S. Noether, and
      A.<br />
      Blue, “Concise linkable ring signatures and forgery against
      adversarial<br />
      keys.” Cryptology ePrint Archive, Paper 2019/654, 2019.
      Available:<br />
      <a href="https://eprint.iacr.org/2019/654"
      class="uri">https://eprint.iacr.org/2019/654</a></div>
      </div>
      <div id="ref-cseedu:brubaker/152groups" class="csl-entry"
      role="listitem">
      <div class="csl-left-margin">[3]<br />
      </div><div class="csl-right-inline">B. Brubaker, “The very basics
      of<br />
      groups, rings, and fields.” 2006. Available:<br />
      <a
      href="https://www-users.cse.umn.edu/~brubaker/docs/152/152groups.pdf"
      class="uri">https://www-users.cse.umn.edu/~brubaker/docs/152/152groups.pdf</a></div>
      </div>
      <div id="ref-electriccoin:pastahalo2" class="csl-entry"
      role="listitem">
      <div class="csl-left-margin">[4]<br />
      </div><div class="csl-right-inline">S. B. Daira Hopwood and J.
      Grigg,<br />
      “The pasta curves for halo 2 and beyond.” Electric Coin Blog,
      2020.<br />
      Available:<br />
      <a
      href="https://electriccoin.co/blog/the-pasta-curves-for-halo-2-and-beyond/"
      class="uri">https://electriccoin.co/blog/the-pasta-curves-for-halo-2-and-beyond/</a></div>
      </div>
      <div id="ref-cryptoeprint:2014/595" class="csl-entry"
      role="listitem">
      <div class="csl-left-margin">[5]<br />
      </div><div class="csl-right-inline">E. Ben-Sasson, A. Chiesa,
      E.<br />
      Tromer, and M. Virza, “Scalable zero knowledge via cycles of
      elliptic<br />
      curves.” Cryptology ePrint Archive, Paper 2014/595, 2014.
      Available:<br />
      <a href="https://eprint.iacr.org/2014/595"
      class="uri">https://eprint.iacr.org/2014/595</a></div>
      </div>
      <div id="ref-cryptostackexchange:106774" class="csl-entry"
      role="listitem">
      <div class="csl-left-margin">[6]<br />
      </div><div class="csl-right-inline">D. S, Answered on Crypto
      Stack<br />
      Exchange, 2023. Available:<br />
      <a href="https://crypto.stackexchange.com/a/106775"
      class="uri">https://crypto.stackexchange.com/a/106775</a></div>
      </div>
      <div id="ref-blogicme:canweavoidcycles" class="csl-entry"
      role="listitem">
      <div class="csl-left-margin">[7]<br />
      </div><div class="csl-right-inline">W. Benno, “Can we avoid cycles
      of<br />
      curves.” Blog, 2023. Available:<br />
      <a href="https://blog.icme.io/can-we-avoid-cycles-of-curves/"
      class="uri">https://blog.icme.io/can-we-avoid-cycles-of-curves/</a></div>
      </div>
      <div id="ref-blogpersonlabs:efficientecdsa" class="csl-entry"
      role="listitem">
      <div class="csl-left-margin">[8]<br />
      </div><div class="csl-right-inline">Personae, “Efficient ECDSA
      &amp; the<br />
      case for client-side proving.” Blog, 2022. Available:<br />
      <a href="https://personaelabs.org/posts/efficient-ecdsa-1/"
      class="uri">https://personaelabs.org/posts/efficient-ecdsa-1/</a></div>
      </div>
      <div id="ref-blogicme:costofrecursion" class="csl-entry"
      role="listitem">
      <div class="csl-left-margin">[9]<br />
      </div><div class="csl-right-inline">W. Benno, “The cost of<br />
      composition: An exploration in the state of the art for foreign
      field<br />
      arithmetic in zero knowledge proofs.” ICME blog, 2024.
      Available:<br />
      <a
      href="https://blog.icme.io/the-cost-of-recursion-explorations-in-the-state-of-the-art-of-foreign-arithmetic/"
      class="uri">https://blog.icme.io/the-cost-of-recursion-explorations-in-the-state-of-the-art-of-foreign-arithmetic/</a></div>
      </div>
      <div id="ref-slides:deepdiveonhalo2" class="csl-entry"
      role="listitem">
      <div class="csl-left-margin">[10]<br />
      </div><div class="csl-right-inline">D. Hopwood and Y. T. Lai,
      “Deep<br />
      dive on halo 2.” Github Repo, 2020. Available:<br />
      <a
      href="https://raw.githubusercontent.com/daira/halographs/master/deepdive.pdf"
      class="uri">https://raw.githubusercontent.com/daira/halographs/master/deepdive.pdf</a></div>
      </div>
      <div id="ref-springer:asurveyproofsys" class="csl-entry"
      role="listitem">
      <div class="csl-left-margin">[11]<br />
      </div><div class="csl-right-inline">Y. E. H. Diego F. Aranha and
      A.<br />
      Guillevic, “A survey of elliptic curves for proof systems.”
      2022-2023.<br />
      Available:<br />
      <a
      href="https://link.springer.com/article/10.1007/s10623-022-01135-y"
      class="uri">https://link.springer.com/article/10.1007/s10623-022-01135-y</a></div>
      </div>
      <div id="ref-cryptoeprint:2017/1066" class="csl-entry"
      role="listitem">
      <div class="csl-left-margin">[12]<br />
      </div><div class="csl-right-inline">D. B. Benedikt Bünz
      Jonathan<br />
      Bootle and G. Maxwell, “Bulletproofs: Short proofs for
      confidential<br />
      transactions and more.” Cryptology ePrint Archive, Paper
      2017/1066,<br />
      2017. Available: <a href="https://eprint.iacr.org/2017/1066"
      class="uri">https://eprint.iacr.org/2017/1066</a></div>
      </div>
      <div id="ref-bernstein2012highspeed" class="csl-entry"
      role="listitem">
      <div class="csl-left-margin">[13]<br />
      </div><div class="csl-right-inline">D. J. Bernstein, N. Duif,
      T.<br />
      Lange, P. Schwabe, and B.-Y. Yang, “High-speed high-security<br />
      signatures,” <em>Journal of Cryptographic Engineering</em>,
      vol. 2, Aug. 2012,<br />
      doi:<br />
      <a
      href="https://doi.org/10.1007/s13389-012-0027-1">10.1007/s13389-012-0027-1</a>.</div>
      </div>
      <div id="ref-githubgist:curve-tower-cycle" class="csl-entry"
      role="listitem">
      <div class="csl-left-margin">[14]<br />
      </div><div class="csl-right-inline">tevador, “Elliptic curve<br />
      tower-cycle for Curve25519.” A Github Gist, 2024. Available:<br />
      <a
      href="https://gist.github.com/tevador/4524c2092178df08996487d4e272b096"
      class="uri">https://gist.github.com/tevador/4524c2092178df08996487d4e272b096</a></div>
      </div>
      </div>
      <h1 id="appendix-a---curve-tower-cycles">Appendix A - Curve-Tower
      Cycles</h1>
      <p>Many protocols and implementations use Curve25519, or more
      specifically,<br />
      its Twisted Edwards form <a
      href="#ref-bernstein2012highspeed">[13]</a>. But<br />
      secure curve cycles with it are impossible because the order of
      its<br />
      (sub)group (generated by its generator point
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>G</mi><annotation encoding="application/x-tex">G</annotation></semantics></math>)
      is not prime, meaning<br />
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">[</mo><mi>n</mi><mo stretchy="true" form="postfix">]</mo></mrow><mi>G</mi><mo>=</mo><mi>𝒪</mi></mrow><annotation encoding="application/x-tex">[n]G = \mathcal{O}</annotation></semantics></math>
      where
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
      isn’t prime. Notice that if we could find<br />
      a 2-cycle with curve
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>#</mi><mi>E</mi><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>𝔽</mi><mi>𝕡</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">\#E[\mathbb{F_p}] = q</annotation></semantics></math>
      and
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>#</mi><mi>E</mi><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>𝔽</mi><mi>𝕢</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">\#E[\mathbb{F_q}] = p</annotation></semantics></math><br />
      and
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><msup><mn>2</mn><mn>255</mn></msup><mo>−</mo><mn>19</mn></mrow><annotation encoding="application/x-tex">p = 2^{255} - 19</annotation></semantics></math><a
      href="#fn10" class="footnote-ref" id="fnref10"
      role="doc-noteref"><sup>10</sup></a>, points on Curve25519 could
      be mapped to<br />
      points on
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>𝔽</mi><mi>𝕢</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">E[\mathbb{F_q}]</annotation></semantics></math>,
      and ‘enter’ the cycle. This is well defined<br />
      because they have the same number of points, meaning they can be
      mapped<br />
      between each other.</p>
      <pre><code>   -- Ep --
 /          \
|            ^
v            |
 \          /
   -- Eq --
      ^
      |
  Curve25519</code></pre>
      <p>tevador called this arrangement a “tower-cycle”. For more
      details about<br />
      the generation of such curves, tevador posted a gist on
      GitHub<br />
      <a href="#ref-githubgist:curve-tower-cycle">[14]</a>.</p>
      <figure>
      <img src="https://imgs.xkcd.com/comics/depth_and_breadth.png"
      alt="Finding curves is fun! But… Bread is probably tastier. (xkcd 2407)" /><br />

      <figcaption aria-hidden="true">
      Finding curves is fun<a href="#fn1"
      class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>!<br />
      But… Bread is probably tastier. (xkcd 2407)
      </figcaption>
      </figure>
      <aside id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
      <hr />
      <ol>
      <li id="fn1">
      <p>
      Those aren’t the right search algorithms/constraints,<br />
      but you get the point.<a href="#fnref1" class="footnote-back"
      role="doc-backlink">↩︎</a>
      </p>
      </li>
      </ol>
      </aside>
      <section id="footnotes"
      class="footnotes footnotes-end-of-document" role="doc-endnotes">
      <hr />
      <ol>
      <li id="fn1"><p>This was just a sidenote – you don’t have to
      understand nor know about FCMPs.<a href="#fnref1"
      class="footnote-back" role="doc-backlink">↩︎</a></p></li>
      <li id="fn2"><p>Ring signatures use decoys to obstruct peopole
      from knowing who the sender is. However, due to how PoW works,
      recents committed blocks can be reordered or removed from the
      chain, thus comprimising privacy. Basically, an attacker can spam
      the network with double spends and force a reorg, and if other
      users use their outputs as decoys, the attacker can deanonymize
      them. Koe talked about this more <a
      href="https://github.com/monero-project/research-lab/issues/95">here</a>.<a
      href="#fnref2" class="footnote-back"
      role="doc-backlink">↩︎</a></p></li>
      <li id="fn3"><p>An enote is an output of a transaction, and can be
      spent once. Change can be saved by having two outputs: one for the
      actual recipient, and one for the change.<a href="#fnref3"
      class="footnote-back" role="doc-backlink">↩︎</a></p></li>
      <li id="fn4"><p>The inner product here is the dot product: take
      two vectors
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub><mo>,</mo><msub><mi>v</mi><mn>2</mn></msub><mo>∈</mo><msup><mi>𝔾</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">v_1, v_2 \in \mathbb{G}^n</annotation></semantics></math>
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">⟨</mo><msub><mi>v</mi><mn>1</mn></msub><mo>,</mo><msub><mi>v</mi><mn>2</mn></msub><mo stretchy="false" form="postfix">⟩</mo><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>v</mi><msub><mn>1</mn><mi>i</mi></msub></msub><mo>⋅</mo><msub><mi>v</mi><msub><mn>2</mn><mi>i</mi></msub></msub></mrow><annotation encoding="application/x-tex">\langle v_1, v_2 \rangle = \sum_{i=1}^n v_{1_i} \cdot v_{2_i}</annotation></semantics></math>.
      Inner product with an elliptic curve group would take
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>∈</mo><msup><mi>𝔾</mi><mi>n</mi></msup><mo>,</mo><mover><mi>G</mi><mo accent="true">→</mo></mover><mo>∈</mo><mi>𝔼</mi><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>𝔽</mi><mi>q</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">v \in \mathbb{G}^n, \vec{G} \in \mathbb{E}[\mathbb{F}_q]</annotation></semantics></math>
      and compute
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>v</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow><msub><mover><mi>G</mi><mo accent="true">→</mo></mover><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\sum_{i=1}^n [v_i]\vec{G}_i</annotation></semantics></math>.<a
      href="#fnref4" class="footnote-back"
      role="doc-backlink">↩︎</a></p></li>
      <li id="fn5"><p>Homomorphic means that there exists a
      homomorphism, a function from one group to another s.t.
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>⊗</mo><mi>H</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>H</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>⊕</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">H(a) \otimes H(b) = H(a \oplus b)</annotation></semantics></math>.
      You can see why Pedersen commitments are homomorphic here:
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>o</mi><mi>m</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>v</mi><mn>1</mn></msub><mo>,</mo><msub><mi>s</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mi>C</mi><mi>o</mi><mi>m</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>v</mi><mn>2</mn></msub><mo>,</mo><msub><mi>s</mi><mn>2</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mo stretchy="false" form="prefix">⟨</mo><msub><mi>v</mi><mn>1</mn></msub><mo>,</mo><mi>G</mi><mo stretchy="false" form="postfix">⟩</mo><mo>+</mo><mo stretchy="false" form="prefix">⟨</mo><msub><mi>v</mi><mn>2</mn></msub><mo>,</mo><mi>G</mi><mo stretchy="false" form="postfix">⟩</mo></mrow><annotation encoding="application/x-tex">Com(v_1, s_1) + Com(v_2, s_2) = \langle v_1, G \rangle + \langle v_2, G \rangle</annotation></semantics></math>
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> </mtext><mspace width="0.333em"></mspace></mrow><mo>+</mo><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>s</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">]</mo></mrow><mi>H</mi><mo>+</mo><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>s</mi><mn>2</mn></msub><mo stretchy="true" form="postfix">]</mo></mrow><mi>H</mi><mo>=</mo><mo stretchy="false" form="prefix">⟨</mo><msub><mi>v</mi><mn>1</mn></msub><mo>+</mo><msub><mi>v</mi><mn>2</mn></msub><mo>,</mo><mi>G</mi><mo stretchy="false" form="postfix">⟩</mo><mo>+</mo><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>s</mi><mn>1</mn></msub><mo>+</mo><msub><mi>s</mi><mn>2</mn></msub><mo stretchy="true" form="postfix">]</mo></mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">\text{ } + [s_1]H + [s_2]H = \langle v_1 + v_2, G \rangle + [s_1 + s_2]H</annotation></semantics></math>
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> </mtext><mspace width="0.333em"></mspace></mrow><mo>=</mo><mi>C</mi><mi>o</mi><mi>m</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>v</mi><mn>1</mn></msub><mo>+</mo><msub><mi>v</mi><mn>2</mn></msub><mo>,</mo><msub><mi>s</mi><mn>1</mn></msub><mo>+</mo><msub><mi>s</mi><mn>2</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\text{ } = Com(v_1 + v_2, s_1 + s_2)</annotation></semantics></math>.
      Note that
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>+</mi><annotation encoding="application/x-tex">+</annotation></semantics></math>
      means different things here: at first it’s point addition on the
      elliptic curve and then it is vector addition.<a href="#fnref5"
      class="footnote-back" role="doc-backlink">↩︎</a></p></li>
      <li id="fn6"><p>The paper assumes you can represent the point at
      infinity, the identity of the elliptic curve group, as (x, y)
      coordinates (in
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><msub><mi>𝔽</mi><mi>q</mi></msub><mn>2</mn></msup><annotation encoding="application/x-tex">{\mathbb{F}_q}^2</annotation></semantics></math>),
      which is true for the pasta curves<a
      href="#ref-electriccoin:pastahalo2">[4]</a>.<a href="#fnref6"
      class="footnote-back" role="doc-backlink">↩︎</a></p></li>
      <li id="fn7"><p>This field’s cardinality is the same as the order
      of the elliptic curve’s subgroup generated by the point. In
      simpler words, its size is the same as the number of points on the
      elliptic curve that we can generate using that point
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>G</mi><annotation encoding="application/x-tex">G</annotation></semantics></math>.
      It is a field if and only if
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>#</mi><mi>E</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>𝔽</mi><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">\#E[\mathbb{F}]</annotation></semantics></math>
      is prime (and thus the subgroup is actually the whole group),
      which is necessary for a curve cycle (defined later). That is not
      the case for curves with cofactor
      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">h &gt; 1</annotation></semantics></math>.
      See <a href="#appendix-a-curve-tower-cycles">Appendix A</a>. For
      more information about subgroups you can read <a
      href="https://crypto.stackexchange.com/questions/95752/how-to-decide-if-a-point-on-a-elliptic-curve-belongs-to-a-group-generated-by-a-g">here</a>.<a
      href="#fnref7" class="footnote-back"
      role="doc-backlink">↩︎</a></p></li>
      <li id="fn8"><p>Using transformations on the field doesn’t work;
      modulo will introduce bias to certain points, for example.<a
      href="#fnref8" class="footnote-back"
      role="doc-backlink">↩︎</a></p></li>
      <li id="fn9"><p>Also, “Proof composition involves verifying proofs
      that themselves verify other proofs, requiring”nesting” of
      operations in different fields” <a
      href="#ref-blogicme:costofrecursion">[9]</a>, and thus inherently
      needs to operate on wrong fields.<a href="#fnref9"
      class="footnote-back" role="doc-backlink">↩︎</a></p></li>
      <li id="fn10"><p>Base field characteristic of Curve25519.<a
      href="#fnref10" class="footnote-back"
      role="doc-backlink">↩︎</a></p></li>
      </ol>
      </section>
    </div>
  </main>
  
  <footer>
    <hr>
    <p>&copy;  </p>
  </footer>
</body>
</html>
